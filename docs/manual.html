<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' content='text/html;charset=utf8'>
  <meta name='generator' content='Ronn-NG/v0.9.1 (http://github.com/apjanke/ronn-ng/tree/0.9.1)'>
  <title>libconfini(3)</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#NAME">NAME</a>
    <a href="#DESCRIPTION">DESCRIPTION</a>
    <a href="#WHAT-IS-AN-INI-FILE-">WHAT IS AN INI FILE?</a>
    <a href="#SUPPORTED-SYNTAXES">SUPPORTED SYNTAXES</a>
    <a href="#GETTING-STARTED">GETTING STARTED</a>
    <a href="#READING-AN-INI-FILE">READING AN INI FILE</a>
    <a href="#PARSING-A-BUFFER-INSTEAD-OF-A-FILE">PARSING A BUFFER INSTEAD OF A FILE</a>
    <a href="#THE-INIFORMAT-DATA-TYPE">THE IniFormat data type</a>
    <a href="#THE-INIFORMATNUM-DATA-TYPE">THE IniFormatNum data type</a>
    <a href="#THE-INISTATISTICS-AND-INIDISPATCH-STRUCTURES">THE IniStatistics and IniDispatch structures</a>
    <a href="#RENDERING">RENDERING</a>
    <a href="#STRING-COMPARISONS">STRING COMPARISONS</a>
    <a href="#ARRAYS">ARRAYS</a>
    <a href="#EDITING-THE-DISPATCHED-DATA">EDITING THE DISPATCHED DATA</a>
    <a href="#IMPLICIT-KEYS">IMPLICIT KEYS</a>
    <a href="#CODE-CONSIDERATIONS">CODE CONSIDERATIONS</a>
    <a href="#INI-SYNTAX-CONSIDERATIONS">INI SYNTAX CONSIDERATIONS</a>
  </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>libconfini(3)</li>
    <li class='tc'>Library Functions Manual</li>
    <li class='tr'>libconfini(3)</li>
  </ol>

  

<h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>libconfini</code>
</p>
<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p><strong>libconfini</strong> is a simple INI parsing library with the ability to read
disabled entries (i.e. valid entries nested in comments). <strong>libconfini</strong> does
not store the data read from an INI file, but rather dispatches it, formatted,
to a custom listener.</p>

<p>The code is written in C (C99) and does not depend on any particular library,
except for the C standard headers <strong>stdio.h</strong>, <strong>stdlib.h</strong>, <strong>stdbool.h</strong> and
<strong>stdint.h</strong>.</p>

<p>If you want to start learning directly from the code, you can find partially
self-documented sample usages of <strong>libconfini</strong> under
<code>/usr/share/doc/libconfini/examples</code>.</p>

<h2 id="WHAT-IS-AN-INI-FILE-">WHAT IS AN INI FILE?</h2>

<p>INI files were introduced with the early versions of Microsoft Windows, where
the .ini file name extension stood for INItialization. An INI file can be
considered as a string representation of a tree object, with new lines used as
delimiters between nodes. A typical INI file is a plain text file looking like
the following example:</p>

<pre><code class="language-{.ini}"># delivery.conf

; general options

location = Colosseum
place = Rome

[sender]
name = John Smith
email = john.smith@example.com

[receiver]
name = Mario Rossi   # He's a big guy
email = mario.rossi@example.com
</code></pre>

<h2 id="SUPPORTED-SYNTAXES">SUPPORTED SYNTAXES</h2>

<p>During the years several interpretations of INI files appeared. In some
implementations the colon character (<code>:</code>) was adopted as delimiter between keys
and values instead of the classic equals sign (a typical example under
GNU/Linux is <code>/etc/nsswitch.conf</code>); in other implementations, under the
influence of Unix standard configuration files, a sequence of one or more
spaces (<code>/[ \t\v\f]+/</code> or <code>/(?:\\(?:\n\r?|\r\n?)|[\t \v\f])+/</code>) was adopted
instead (see for example <code>/etc/host.conf</code>).</p>

<p>Equals sign used as delimiter between keys and values:</p>

<pre><code class="language-{.ini}"># example1.ini

home = Champ de Mars, 5 Avenue Anatole
city = Paris
</code></pre>

<p>Colon sign used as delimiter between keys and values:</p>

<pre><code class="language-{.ini}"># example2.ini

home: Champ de Mars, 5 Avenue Anatole
city: Paris
</code></pre>

<p>Space sequence used as delimiter between keys and values:</p>

<pre><code class="language-{.ini}"># example3.ini

home	Champ de Mars, 5 Avenue Anatole
city	Paris
</code></pre>

<p><strong>libconfini</strong> was born as a general INI parser for <strong>GNU</strong>, so the support of
most part of INI dialects has been implemented within it.</p>

<p>Especially in <strong>Microsoft Windows</strong> a more radical syntax variation found its
way into INI files: the use of semicolon, instead of new lines, as delimiter
between nodes, as in the following example:</p>

<pre><code class="language-{.ini}"># delivery.conf

; general options

location=Colosseum;place=Rome;[sender] name=John Smith;
email=john.smith@example.com;
[receiver] name=Mario Rossi; # He's a big guy
email=mario.rossi@example.com
</code></pre>

<p>For several reasons the use of semicolon as node delimiter is not (and will
never be) supported by <strong>libconfini</strong>.</p>

<h3 id="KEYS">KEYS</h3>

<p>A <strong>key-value element</strong> is identified as a string placed after a new line and
followed by a key-value delimiter &ndash; typically the equals sign (<code>=</code>) or the
colon sign (<code>:</code>) or a space sequence (<code>/\s+/</code>) &ndash; which is followed by a value,
which is followed by a new line or an inline comment.</p>

<p>Both the <strong>key part</strong> and the <strong>value part</strong> may be enclosed within quotes (<code>'</code>
or <code>"</code>):</p>

<pre><code class="language-{.ini}">foo = 'bar'
"hello" = world
"artist" = "Pablo Picasso"
</code></pre>

<p>The <strong>key part</strong> can contain any character, except the delimiter (although this
may be enclosed within quotes for not beeing considered as such). In multi-line
formats internal new line sequences must be escaped (<code>/\\(?:\n\r?|\r\n?)/</code>).</p>

<p>If the <strong>key part</strong> part is missing <strong>libconfini</strong> considers the element of
<em>unknown type</em> (example: <code>= foo</code>). If the <strong>value part</strong> is missing the key
element is considered empty (example: <code>foo =</code>). If the delimiter is missing
(and therefore the value part as well), according to some formats the key
element is is considered to be an <em>implicit key</em> &ndash; typically representing the
boolean <code>true</code> (example: <code>foo</code>). For instance, in the following example from
<code>/etc/pacman.conf</code>, <code>IgnorePkg</code> is an empty key, while <code>Color</code> is an implicit
key representing a <code>true</code> boolean &ndash; i.e. <code>Color = YES</code>:</p>

<pre><code class="language-{.ini}">HoldPkg = pacman glibc
Architecture = auto
IgnorePkg =
Color
SigLevel = Required DatabaseOptional
LocalFileSigLevel = Optional
</code></pre>

<p>The <strong>value</strong> part can contain typed data, usually: a boolean (booleans
supported by <strong>libconfini</strong> are: <code>FALSE</code>/<code>TRUE</code>, <code>NO</code>/<code>YES</code>, <code>OFF</code>/<code>ON</code> &ndash; 
case-insensitive), a string, a number, or an array (typically with commas or
spaces as delimiters between members &ndash; examples: <code>paths = /etc, /usr,
/home/john/Personal Data</code> or <code>paths = /etc /usr "/home/john/Personal Data"</code>).
In multi-line formats internal new line sequences must be escaped
(<code>/\\(?:\n\r?|\r\n?)/</code>).</p>

<pre><code class="language-{.ini}">[my_section]

my_string = "Hello world"
'my_number' = 42
my_boolean = NO
my_implicit_boolean
my_array = Asia, Africa, 'North America', South America, \
           Antarctica, Europe, Australia
</code></pre>

<h3 id="SECTIONS">SECTIONS</h3>

<p>A <strong>section</strong> can be imagined as a directory. A <strong>section path</strong> is identified
as the string <code>"$1"</code> in the regular expression
<code>/(?:^|\n|\r)[ \t\v\f]*\[[ \t\v\f]*([^\]]*)[ \t\v\f]*\][ \t\v\f]*(?:\n|\r|$)/</code>
globally applied to an INI file. A section path expresses nesting using the
&ldquo;dot&rdquo; character, as in the following example:</p>

<pre><code class="language-{.ini}">[section]

foo = bar

[section.subsection]

foo = bar
</code></pre>

<p>A section path starting with a dot expresses nesting to the previous section.
Hence the last example is equivalent to:</p>

<pre><code class="language-{.ini}">[section]

foo = bar

[.subsection]

foo = bar
</code></pre>

<p>Keys appearing before any section path belong to a virtual <em>root</em> node (with an
empty string as path), as the key <code>foo</code> in the following example:</p>

<pre><code class="language-{.ini}">foo = bar

[options]

interval = 3600

[host]

address = 127.0.0.1
port = 80
</code></pre>

<p>Section parts may be enclosed within quotes:</p>

<pre><code class="language-{.ini}">["world".europe.'germany'.berlin]

foo = bar
</code></pre>

<h3 id="COMMENTS">COMMENTS</h3>

<p>Comments are string segments enclosed within the sequence <code>/(?:^|\s)[;#]/</code> and
a new line sequence, as in the following example:</p>

<pre><code class="language-{.ini}"># this is a comment

foo = bar       # this is an inline comment

; this is another comment
</code></pre>

<p>Comments may in theory be multi-line, following the same syntax of multi-line
disabled entries (see below). This is usually of little utility, except for
inline comments you want to make sure will refer to the previous entry:</p>

<pre><code class="language-{.ini}">play1 = The Tempest

play2 = Twelfth Night # If music be the food of love, play on;      \
                      # Give me excess of it; that, surfeiting,     \
                      # The appetite may sicken, and so die.        \
                      # That strain again; it had a dying fall:     \
                      # O, it came oer my ear, like the sweet sound \
                      # That breathes upon a bank of violets,       \
                      # Stealing, and giving odour! Enough! No more.\
                      # 'Tis not so sweet now as it was before.     \
                      #                                             \
                      #     Orsino, scene I

# This is also a masterpiece
play3 = The Merchant of Venice
</code></pre>

<h3 id="DISABLED-ENTRIES">DISABLED ENTRIES</h3>

<p>A disabled entry is either a section or a key that has been nested inside a
comment as its only child. Inline comments cannot represent disabled entries.
According to some formats disabled entries can be multi-line, using
<code>/\\(?:\n\r?|\r\n?)[\t \v\f]*[;#]/</code> as multi-line escape sequence. For example:</p>

<pre><code class="language-{.ini}">#this = is \
 #a \
    #multi-line \
#disabled \
  #entry
</code></pre>

<h3 id="ESCAPE-SEQUENCES">ESCAPE SEQUENCES</h3>

<p>In order to maximize the flexibility of the data, only four escape sequences
are supported by <strong>libconfini</strong>: <code>\'</code>, <code>\"</code>, <code>\\</code> and the multi-line escape
sequence (<code>/\\(?:\n\r?|\r\n?)/</code>).</p>

<p>The first three escape sequences are left untouched by all functions except
<code>ini_string_parse()</code> and <code>ini_unquote()</code> (see below). Nevertheless, the
characters <code>'</code>, <code>"</code> and <code>\</code> can determine different behaviors during the
parsing depending on whether they are escaped or unescaped. For instance, the
string <code>johnsmith !"</code> in the following example will not be parsed as a comment:</p>

<pre><code class="language-{.ini}">[users.jsmith]

comment = "hey! have a look at my hashtag #johnsmith !"
</code></pre>

<p>A particular case of escape sequence is the multi-line escape sequence
(<code>/\\(?:\n\r?|\r\n?)/</code>), which in multi-line INI files gets <em>immediately
unescaped by <strong>libconfini</strong></em>.</p>

<pre><code class="language-{.ini}">foo = this\
is\
a\
multi-line\
value
</code></pre>

<h2 id="GETTING-STARTED">GETTING STARTED</h2>

<p>The API is contained in one single public header:</p>

<pre><code class="language-{.c}">#include &lt;confini.h&gt;
</code></pre>

<p>When <strong>libconfini</strong> is used as a shared library, it might be wiser to include
<em>the versioned header</em> (with only the major version number appended to the file
name), in order to ensure that the code will compile correctly even when
different major versions of the library cohabit in the same machine. This can
apply also to version 1.X.X:</p>

<pre><code class="language-{.c}">#include &lt;confini-1.h&gt;
</code></pre>

<h2 id="READING-AN-INI-FILE">READING AN INI FILE</h2>

<p>#1 Using a pointer to a <code>FILE</code> handle:</p>

<pre><code class="language-{.c}">int load_ini_file (
    FILE * ini_file,
    IniFormat format,
    IniStatsHandler f_init,
    IniDispHandler f_foreach,
    void * user_data
)
</code></pre>

<p>#2 Using a path:</p>

<pre><code class="language-{.c}">int load_ini_path (
    const char * path,
    IniFormat format,
    IniStatsHandler f_init,
    IniDispHandler f_foreach,
    void * user_data
)
</code></pre>

<p>where</p>

<ul>
  <li>
<code>ini_file</code> in <code>load_ini_file()</code> is the <code>FILE</code> handle pointing to the INI file</li>
  <li>
<code>path</code> in <code>load_ini_path()</code> is the path where the INI file is located
(pointer to a char array, a.k.a. a "C string")</li>
  <li>
<code>format</code> is a bitfield that defines the syntax of the INI file (see <code>struct</code>
<code>IniFormat</code>)</li>
  <li>
<code>f_init</code> is the function that will be invoked <em>before</em> any dispatching begins
&ndash; it can be <code>NULL</code>
</li>
  <li>
<code>f_foreach</code> is the callback function that will be repeatedly invoked for each
member of the INI file - it can be <code>NULL</code>
</li>
  <li>
<code>user_data</code> is a pointer to a custom argument &ndash; it can be <code>NULL</code>
</li>
</ul>

<p>The user given function <code>f_init</code> (see <code>IniStatsHandler</code> data type) will be
invoked with two arguments:</p>

<ul>
  <li>
<code>statistics</code> &ndash; a pointer to an <code>IniStatistics</code> object containing some
properties about the file read (like its size in bytes and the number of its
members)</li>
  <li>
<code>user_data</code> &ndash; a pointer to the custom argument previously passed to the
<code>load_ini_file()</code> / <code>load_ini_path()</code> functions</li>
</ul>

<p>The user given function <code>f_foreach</code> (see <code>IniDispHandler</code> data type) will be
invoked with two arguments:</p>

<ul>
  <li>
<code>dispatch</code> &ndash; a pointer to an <code>IniDispatch</code> object containing the parsed
member of the INI file</li>
  <li>
<code>user_data</code> &ndash; a pointer to the custom argument previously passed to the
<code>load_ini_file()</code> / <code>load_ini_path()</code> functions</li>
</ul>

<p>Both functions <code>load_ini_file()</code> and <code>load_ini_path()</code> will return zero if the
INI file has been completely dispatched, non-zero otherwise.</p>

<h3 id="BASIC-EXAMPLES">BASIC EXAMPLES</h3>

<p>#1 Using a pointer to a <code>FILE</code> handle:</p>

<pre><code class="language-{.c}">/*  examples/topics/load_ini_file.c  */

#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

static int my_callback (
  IniDispatch * const dispatch,
  void * const v_null
) {

  printf(
    "DATA: %s\nVALUE: %s\nNODE TYPE: %u\n\n",
    dispatch-&gt;data, dispatch-&gt;value, dispatch-&gt;type
  );

  return 0;

}

int main () {

  /*  Use always `"rb"` with `load_ini_file()`!  */
  FILE * const ini_file = fopen("../ini_files/delivery.conf", "rb");

  if (ini_file == NULL) {

    fprintf(stderr, "File doesn't exist :-(\n");
    return 1;

  }

  if (
    load_ini_file(
      ini_file,
      INI_DEFAULT_FORMAT,
      NULL,
      my_callback,
      NULL
    )
  ) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  fclose(ini_file);

  return 0;

}
</code></pre>

<p>#2 Using a path:</p>

<pre><code class="language-{.c}">/*  examples/topics/load_ini_path.c  */

#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

static int my_callback (
  IniDispatch * const dispatch,
  void * const v_null
) {

  printf(
    "DATA: %s\nVALUE: %s\nNODE TYPE: %u\n\n",
    dispatch-&gt;data, dispatch-&gt;value, dispatch-&gt;type
  );

  return 0;

}

int main () {

  if (
    load_ini_path(
      "../ini_files/delivery.conf",
      INI_DEFAULT_FORMAT,
      NULL,
      my_callback,
      NULL
    )
  ) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  return 0;

}
</code></pre>

<h3 id="HOW-IT-WORKS">HOW IT WORKS</h3>

<p>The function <code>load_ini_path()</code> is a clone of <code>load_ini_file()</code> that requires a
path instead of a <code>FILE</code> handle.</p>

<p>Both functions <code>load_ini_file()</code> and <code>load_ini_path()</code> dynamically allocate at
once the whole INI file into the heap, and the two structures <code>IniStatistics</code>
and <code>IniDispatch</code> into the stack. All members of the INI file are then
dispatched to the custom listener <code>f_foreach()</code>. Finally the allocated memory
gets automatically freed.</p>

<p>Because of this mechanism <em>it is very important that all the dispatched data be
<strong>immediately</strong> copied by the user (when needed), and no pointers to the passed
data be saved</em>: after the end of the functions <code>load_ini_file()</code> /
<code>load_ini_path()</code> all the allocated data will be destroyed indeed &ndash; and
moreover each dispatch might overwrite data from previous dispatches.</p>

<p>Within a dispatching cycle, the structure containing each dispatch
(<code>IniDispatch * dispatch</code>) is always the same <code>struct</code> that gets constantly
updated with new information.</p>

<p><em><strong>Note:</strong> In some platforms, such as Microsoft Windows, it
might be necessary to add the binary specifier (<code>"b"</code>) to the mode string of
the <code>FILE</code> handle passed to <code>load_ini_file()</code> in order to prevent discrepancies
between the physical size and the computed size of the file:</em></p>

<pre><code class="language-{.c}">FILE * ini_file = fopen("example.conf", "rb");
</code></pre>

<h2 id="PARSING-A-BUFFER-INSTEAD-OF-A-FILE">PARSING A BUFFER INSTEAD OF A FILE</h2>

<p>Starting from version 1.10.0, it is possible to parse a disposable buffer
containing an INI file instead of a physical file (i.e., to parse a <code>char</code>
array). The function that allows to do so is named <code>strip_ini_cache()</code>. This
function presents some important differences when compared to <code>load_ini_file()</code>
and <code>load_ini_path()</code>:</p>

<ol>
  <li>As the name suggests, the buffer passed is not left untouched, but gets
tokenized and rearranged instead &ndash; if you want to keep the original buffer
you must pass a copy of it to <code>strip_ini_cache()</code> &ndash; you can use <code>strndup()</code>
for this, or use the example below</li>
  <li>No memory is freed after the dispatching cycle is over: getting rid of the
disposable buffer is something that must be done manually</li>
  <li>The strings dispatched are all tokens from the buffer passed as argument (no
new memory is ever allocated), but the existence of each token is granted
only for a short time, that is <em>until the dispatch of the next node</em> (in
fact the latter may overwrite previous information) &ndash; therefore, as with
<code>load_ini_file()</code> and <code>load_ini_path()</code>, every needed information must be
copied immediately with each dispatch</li>
  <li>After the dispatching cycle is over, the buffer passed as argument must be
regarded as <em>unreliable information</em> (portions of it might have been
repeatedly overwritten and corrupted by subsequent dispatches)</li>
</ol>

<p>In short, <code>strip_ini_cache()</code> works exactly like <code>load_ini_file()</code> and
<code>load_ini_path()</code>, but with the difference that it destroys the input while it
dispatches it. And of course the input is not anymore a file, but a disposable
buffer instead. As a matter of fact, <code>strip_ini_cache()</code> is the main parsing
function both <code>load_ini_file()</code> and <code>load_ini_path()</code> rely on in order to
dispatch the content of an INI file. For a sample usage, please see
<code>examples/topics/strip_ini_cache.c</code>.</p>

<p>If you want to automatize the process of making a copy of a read-only buffer,
strip and parse the copy, then free the allocated memory, you can use the
following function:</p>

<pre><code class="language-{.c}">/*  examples/utilities/load_ini_buffer.h  */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;confini.h&gt;

/**

  @brief    Parse a `const` string containing an INI file
  @param    ini_buffer      The buffer containing the INI file to
                            parse
  @param    ini_length      The length of @p ini_buffer
  @param    format          The format of the INI file
  @param    f_init          The function that will be invoked before
                            the first dispatch, or `NULL`

  @param    f_foreach       The function that will be invoked for
                            each dispatch, or `NULL`
  @param    user_data       A custom argument, or `NULL`
  @return   Zero for success, otherwise an error code (see `enum`
            #ConfiniInterruptNo)

**/
int load_ini_buffer (
  const char * const ini_buffer,
  const size_t ini_length,
  const IniFormat format,
  const IniStatsHandler f_init,
  const IniDispHandler f_foreach,
  void * const user_data
) {

  char * const ini_cache = strndup(ini_buffer, ini_length);

  if (!ini_cache) {

    return CONFINI_ENOMEM;

  }

  const int retval = strip_ini_cache(
    ini_cache,
    ini_length,
    format,
    f_init,
    f_foreach,
    user_data
  );

  free(ini_cache);

  return retval;

}
</code></pre>

<p>The function above can then be invoked directly on a <code>const</code> buffer:</p>

<pre><code class="language-{.c}">load_ini_buffer(
  my_const_buffer,
  strlen(my_const_buffer),
  my_format,
  my_stats_handler,
  my_callback,
  my_other_data
);
</code></pre>

<p>Since in most cases an INI buffer <em>is</em> a disposable buffer (unless one wants to
parse the very same buffer more than once), <strong>libconfini</strong>'s interface does not
include the function in the example above.</p>

<h2 id="THE-IniFormat-data-type">THE <code>IniFormat</code> data type</h2>

<p>For a correct use of this library it is helpful to understand the <code>IniFormat</code>
data type. <strong>libconfini</strong> has been born as a general INI parser, with the main
purpose of <em>being able to parse INI files written by other programs</em> (see
<strong>Rationale</strong>), therefore some flexibility was required. When an INI file is
parsed it is parsed according to a particular format. The <code>IniFormat</code> data type
is a univocal description of such format. It is implemented as a 24-bit
bitfield. Its small size (3 bytes) allows it to be passed by value to the
functions that require it.</p>

<p>Since no function requires a pointer to an <code>IniFormat</code> data type as argument, a
preprocessor macro can be a good place where to store a custom format:</p>

<pre><code class="language-{.c}">#define MY_FORMAT \
  ((IniFormat) { \
    .delimiter_symbol = INI_EQUALS, \
    .case_sensitive = false, \
    .semicolon_marker = INI_IGNORE, \
    .hash_marker = INI_IGNORE, \
    .section_paths = INI_ABSOLUTE_AND_RELATIVE, \
    .multiline_nodes = INI_MULTILINE_EVERYWHERE, \
    .no_single_quotes = false, \
    .no_double_quotes = false, \
    .no_spaces_in_names = false, \
    .implicit_is_not_empty = false, \
    .do_not_collapse_values = false, \
    .preserve_empty_quotes = false, \
    .disabled_after_space = false, \
    .disabled_can_be_implicit = false \
  })

if (load_ini_path("example.conf", MY_FORMAT, NULL, my_cb, NULL)) {

  fprintf(stderr, "Sorry, something went wrong :-(\n");
  return 1;

}
</code></pre>

<h3 id="THE-MODEL-FORMATS">THE MODEL FORMATS</h3>

<p>A default format named <code>INI_DEFAULT_FORMAT</code> is available.</p>

<pre><code class="language-{.c}">IniFormat my_default_format;

my_default_format = INI_DEFAULT_FORMAT;
</code></pre>

<p>The code above corresponds to:</p>

<pre><code class="language-{.c}">IniFormat my_default_format;

my_default_format.delimiter_symbol = INI_EQUALS;  // or '='
my_default_format.case_sensitive = false;
my_default_format.semicolon_marker = INI_DISABLED_OR_COMMENT;
my_default_format.hash_marker = INI_DISABLED_OR_COMMENT;
my_default_format.section_paths = INI_ABSOLUTE_AND_RELATIVE;
my_default_format.multiline_nodes = INI_MULTILINE_EVERYWHERE;
my_default_format.no_single_quotes = false;
my_default_format.no_double_quotes = false;
my_default_format.no_spaces_in_names = false;
my_default_format.implicit_is_not_empty = false;
my_default_format.do_not_collapse_values = false;
my_default_format.preserve_empty_quotes = false;
my_default_format.disabled_after_space = false;
my_default_format.disabled_can_be_implicit = false;
</code></pre>

<p>or, equivalently, in macro form:</p>

<pre><code class="language-{.c}">#define my_default_format \
  ((IniFormat) { \
    .delimiter_symbol = INI_EQUALS,  /*  or '='  */ \
    .case_sensitive = false, \
    .semicolon_marker = INI_DISABLED_OR_COMMENT, \
    .hash_marker = INI_DISABLED_OR_COMMENT, \
    .section_paths = INI_ABSOLUTE_AND_RELATIVE, \
    .multiline_nodes = INI_MULTILINE_EVERYWHERE, \
    .no_single_quotes = false, \
    .no_double_quotes = false, \
    .no_spaces_in_names = false, \
    .implicit_is_not_empty = false, \
    .do_not_collapse_values = false, \
    .preserve_empty_quotes = false, \
    .disabled_after_space = false, \
    .disabled_can_be_implicit = false \
  })
</code></pre>

<p>Starting from version 1.7.0 a format named <code>INI_UNIXLIKE_FORMAT</code> is available.</p>

<pre><code class="language-{.c}">IniFormat my_unixlike_format = INI_UNIXLIKE_FORMAT;
</code></pre>

<p>This format is a clone of <code>INI_DEFAULT_FORMAT</code> with the only exception of
<code>IniFormat::delimiter_symbol</code>, whose value is set to <code>INI_ANY_SPACE</code> instead
of <code>INI_EQUALS</code>.</p>

<p>The semantics of the <code>IniFormat</code> bitfield has been designed in order to ensure
that when all its fields are set to zero it equals <code>INI_UNIXLIKE_FORMAT</code>.</p>

<pre><code class="language-{.c}">IniFormat format_zero = (IniFormat) { 0 };

printf(

  "`format_zero` and `INI_UNIXLIKE_FORMAT` are %s.\n",

  memcmp(&amp;format_zero, &amp;INI_UNIXLIKE_FORMAT, sizeof(IniFormat)) ?
    "not equal"
  :
    "equal"

); // "`format_zero` and `INI_UNIXLIKE_FORMAT` are equal."
</code></pre>

<p>For further formats, please refer to the <a href="https://github.com/madmurphy/libconfini/wiki/INI-formats">extensible list of common formats</a>
in the project's wiki. Feel free to contribute.</p>

<h2 id="THE-IniFormatNum-data-type">THE <code>IniFormatNum</code> data type</h2>

<p>Each format can be represented also as a univocal 24-bit unsigned integer. In
order to convert an <code>IniFormat</code> to an unsigned integer and vice versa the
functions <code>ini_fton()</code> and <code>ini_ntof()</code> are available. For simplicity, instead
of using a <code>uint_least32_t</code> type, a size-agnostic custom type is used for this:
the <code>IniFormatNum</code> data type.</p>

<p>For instance, imagine we want to create a format as close as possible to the
typical Windows INI files. Probably we would define our format as follows:</p>

<pre><code class="language-{.c}">IniFormat my_format = {
  .delimiter_symbol = INI_EQUALS,
  .case_sensitive = false,
  .semicolon_marker = INI_ONLY_COMMENT,
  .hash_marker = INI_IS_NOT_A_MARKER,
  .section_paths = INI_ABSOLUTE_ONLY,
  .multiline_nodes = INI_NO_MULTILINE,
  .no_single_quotes = false,
  .no_double_quotes = false,
  .no_spaces_in_names = false,
  .implicit_is_not_empty = false,
  .do_not_collapse_values = false,
  .preserve_empty_quotes = false,
  .disabled_after_space = false,
  .disabled_can_be_implicit = false
};

IniFormatNum my_format_num = ini_fton(my_format);

printf("Format No. %u\n", my_format_num); // "Format No. 56637"
</code></pre>

<p>According to the <code>ini_fton()</code> function this format is univocally the format
No. 56637. The function <code>ini_ntof()</code> then gives us a shortcut to construct the
very same format using its format number. Hence, the code above corresponds to:</p>

<pre><code class="language-{.c}">IniFormat my_format = ini_ntof(56637);
</code></pre>

<h2 id="THE-IniStatistics-and-IniDispatch-structures">THE <code>IniStatistics</code> and <code>IniDispatch</code> structures</h2>

<p>When the functions <code>load_ini_file()</code>, <code>load_ini_path()</code> read an INI file, or
when the function <code>strip_ini_cache()</code> parses a buffer, they dispatch the file
content to the <code>f_foreach()</code> listener. Before the dispatching begins some
statistics about the parsed file can be dispatched to the <code>f_init()</code> listener
(if this is non-<code>NULL</code>).</p>

<p>The information passed to <code>f_init()</code> is passed through an <code>IniStatistics</code>
structure, while the information passed to <code>f_foreach()</code> is passed through an
<code>IniDispatch</code> structure.</p>

<h2 id="RENDERING">RENDERING</h2>

<p>The output strings dispatched by <strong>libconfini</strong> follow some formatting rules
depending on their role within the INI file. First, multi-line escape sequences
will be unescaped, then</p>

<ul>
  <li>
<strong>Key names</strong> will be rendered according to ECMAScript
<code>key_name.replace(/^[\n\r]\s*|\s+/g, " ")</code> &ndash; within single or double quotes,
if active, the text will be rendered verbatim.</li>
  <li>
<strong>Section paths</strong>, if format supports nesting, will be rendered according to
ECMAScript
<code>section_name.replace(/\.*\s*$|(?:\s*(\.))+\s*|^\s+/g, "$1").replace(/\s+/g,
" ")</code> &ndash; within single or double quotes, if active, the text will be rendered
verbatim &ndash; otherwise, will be rendered according to the same algorithm used
for key names.</li>
  <li>
<strong>Values</strong>, if <code>format.do_not_collapse_values</code> is active, will only be
cleaned of spaces at the beginning and at the end; otherwise will be rendered
according to the same algorithm used for key names (with the difference that,
if <code>format.preserve_empty_quotes</code> is set to <code>true</code>, empty quotes surrounded
by spaces will be preserved).</li>
  <li>
<strong>Comments</strong>, in multi-line formats, will be rendered according to ECMAScript
<code>comment_string.replace(/(^|\n\r?|\r\n?)[ \t\v\f]*[#;]+/g, "$1")</code>; elsewhere,
according to ECMAScript <code>comment_string.replace(/^[ \t\v\f]*[#;]+/, "")</code>.</li>
  <li>
<strong>Unknown nodes</strong> will be rendered verbatim.</li>
</ul>

<h2 id="STRING-COMPARISONS">STRING COMPARISONS</h2>

<p>In order to perform comparisons between the strings dispatched the functions
<code>ini_string_match_ss()</code>, <code>ini_string_match_si()</code>, <code>ini_string_match_ii()</code> and
<code>ini_array_match()</code> are available. The function <code>ini_string_match_ss()</code>
compares two simple strings, the function <code>ini_string_match_si()</code> compares a
simple string with an unparsed INI string, the function <code>ini_string_match_ii()</code>
compares two unparsed INI strings, and the function <code>ini_array_match()</code>
compares two INI arrays. INI strings are the strings typically dispatched by
<code>load_ini_file()</code>, <code>load_ini_path()</code> or <code>strip_ini_cache()</code> which may contain
quotes and the three escape sequences <code>\\</code>, <code>\'</code>, <code>\"</code>. Simple strings are
user-given strings or the result of <code>ini_string_parse()</code>.</p>

<p>As a consequence, the functions <code>ini_string_match_si()</code>,
<code>ini_string_match_ii()</code> and <code>ini_array_match()</code> do not perform literal
comparisons of equality between strings. For example, in the following (absurd)
INI file the two keys <code>foo</code> and <code>hello</code> belong to the same section named <code>this
is a double quotation mark: "!</code> (after being parsed by <code>ini_string_parse()</code>).</p>

<pre><code class="language-{.ini}">[this is a double quotation mark: \"!]

foo = bar

[this is a double quotation mark: '"'!]

hello = world
</code></pre>

<p>Therefore...</p>

<pre><code class="language-{.c}">char
  string1[] = "This is a double quotation mark: \\\"!",
  string2[] = "This is a double quotation mark: '\"'!";

printf(
  "%s\n",

  ini_string_match_ii(string1, string2, INI_DEFAULT_FORMAT) ?
    "They match"
  :
    "They don't match"
);  // "They match"
</code></pre>

<p>Or, for instance, in the following example the first two arrays are considered
equal, while the third one is considered different.</p>

<pre><code class="language-{.c}">#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

int main () {

  char
    list_1[] = "foo:bar  :  apple : 'I said: wait!' :   bye bye  ",
    list_2[] = "'foo':'bar':'apple':'I said: wait!':'bye'   bye",
    list_3[] = "foo:bar:tomorrow:apple:I said: wait!:bye bye";

  printf(
    "%s\n",
    ini_array_match(list_1, list_2, ':', INI_DEFAULT_FORMAT) ?
      "They match"
    :
      "They don't match"
  );  // "They match"


  printf(
    "%s\n",
    ini_array_match(list_1, list_3, ':', INI_DEFAULT_FORMAT) ?
      "They match"
    :
      "They don't match"
  );  // "They don't match"

  return 0;

}
</code></pre>

<p>In formats that support quotes, the function <code>ini_array_match()</code> is also the
function that should be used, with <code>'.'</code> or <code>INI_DOT</code> as delimiter (see <code>enum</code>
<code>IniDelimiters</code>), to compare properly section paths containing more than one
level of nesting.</p>

<pre><code class="language-{.c}">if (
  ini_array_match("foo.bar", disp-&gt;append_to, '.', disp-&gt;format) &amp;&amp;
  ini_string_match_si("username", disp-&gt;data, disp-&gt;format)
) {

  // Do something

}
</code></pre>

<p>In case of multiple comparisons you might want to use a macro:</p>

<pre><code class="language-{.c}">static int my_callback (IniDispatch * dsp, void * v_my_data) {

  #define IS_KEY(SECTION, KEY) \
    (ini_array_match(SECTION, dsp-&gt;append_to, '.', dsp-&gt;format) &amp;&amp; \
    ini_string_match_ii(KEY, dsp-&gt;data, dsp-&gt;format))

  if (dsp-&gt;type == INI_KEY) {

    if (IS_KEY("europe.madrid", "have_visited")) {

      // Do something

    } else if (IS_KEY("europe.london", "date")) {

      // Do something

    } else if (...) {

      // etc.

    }

  }

  #undef IS_KEY

}
</code></pre>

<p>The four functions <code>ini_string_match_ss()</code>, <code>ini_string_match_si()</code>,
<code>ini_string_match_ii()</code>, <code>ini_array_match()</code> perform case-sensitive or
case-insensitive comparisons depending on the format given. UTF-8 codepoints
out of the ASCII range are always compared case-sensitive.</p>

<p>Note that within INI strings empty quotes and spaces out of quotes are always
collapsed during comparisons. Furthermore, remember that the multi-line escape
sequence <code>/\\(?:\n\r?|\r\n?)/</code> is <em>not</em> considered as such in INI strings,
since this is the only escape sequence automatically unescaped by
<strong>libconfini</strong> before each dispatch.</p>

<h2 id="ARRAYS">ARRAYS</h2>

<p>It is possible with <strong>libconfini</strong> to parse INI strings as arrays. In order to
avoid that any particular character be treated as a metacharacter throughout an
entire configuration file, INI arrays do not have a fixed delimiter symbol
specified in the INI format.</p>

<p>Abstractly speaking, this means that array delimiters are not part of the INI
syntax, but of the INI semantics instead. Concretely speaking, it means that
developers have to provide a delimiter as soon as they decide to parse an INI
string as an array.</p>

<p>Out in the wild, the most widespread INI array delimiter is probably the space
sequence (<code>INI_ANY_SPACE</code> &ndash; i.e. <code>/(?:\\(?:\n\r?|\r\n?)|[\t \v\f])+/</code> or
<code>/[ \t\v\f]+/</code>, depending on whether the format is multi-line or not). Another
widespread delimiter is the comma (<code>','</code> or <code>INI_COMMA</code>). Besides these two,
occasionally other characters can be found as array delimiters (<code>':'</code>, <code>'|'</code>,
<code>';'</code>, ...).</p>

<p>For iterating through an INI array using a delimiter <strong>libconfini</strong> provides
the following tools:</p>

<ul>
  <li><code>ini_array_get_length()</code></li>
  <li><code>ini_array_foreach()</code></li>
  <li><code>ini_array_collapse()</code></li>
  <li><code>ini_array_break()</code></li>
  <li><code>ini_array_release()</code></li>
  <li><code>ini_array_shift()</code></li>
  <li><code>ini_array_split()</code></li>
</ul>

<p>None of the functions above actually ever allocates any array, as
<strong>libconfini</strong> does not know what kind of data type an array should be composed
of &ndash; the developer might be looking for an array of strings, or an array of
integers, or anything else. These tools only provide safe mechanisms to iterate
through, or tokenize, the members of INI arrays according to the format and the
delimiter given &ndash; making sure for example that when the delimiter symbol is
found nested within quotes it is treated as a normal character &ndash; but
allocating memory is something that must be done manually.</p>

<p>An example function that parses INI strings as newly allocated arrays of C
strings is available under <code>examples/utilities/make_strarray.h</code>. If your
program requires other data types (such as integers, booleans, etc.) you may
adapt that example to your needs.</p>

<h2 id="EDITING-THE-DISPATCHED-DATA">EDITING THE DISPATCHED DATA</h2>

<p>The strings dispatched, as already said, must not be freed. Nevertheless,
<em>before being copied or analyzed they can be edited, <strong>with some precautions</strong></em>:</p>

<ol>
  <li>Be sure that your edit remains within the buffer lengths given (see
<code>IniDispatch::d_len</code> and <code>IniDispatch::v_len</code>).</li>
  <li>Do not edit the <code>IniDispatch::data</code> field of a section: the
<code>IniDispatch::append_to</code> properties of its children will either share this
buffer or will concatenate it to another buffer. Thus, if you edit its
content &ndash; and depending on how you edit it &ndash; you might be no more able to
rely on the <code>IniDispatch::append_to</code> properties of this node's children. You
would not make any damage, the loop will continue just fine: so if you think
you are never going to use the property <code>IniDispatch::append_to</code>, just do
it; alternatively, use <code>strndup()</code>. If instead <code>IniDispatch::data</code> contains
a key name or a comment, it is granted that no other dispatch will share
this buffer, so feel free to edit it before it gets lost.</li>
  <li>Regarding <code>IniDispatch::value</code>, if it does not represent an implicit value
(see <strong>&sect; Implicit keys</strong>) or if <code>IniFormat::implicit_is_not_empty</code> is set to
<code>false</code>, this buffer is never shared between dispatches, so feel free to
edit it.</li>
  <li>Regarding <code>IniDispatch::append_to</code>, this buffer is likely to be shared with
other dispatches. Again, you would not destroy the world nor generate
errors, but you would make the next <code>IniDispatch::append_to</code>s useless. For
this reason <strong>the buffer pointed by <code>IniDispatch::append_to</code> is passed as
constant</strong>. To unquote the path parts listed in this field please use
<code>strndup()</code>.</li>
  <li>The numerical addresses of the pointers <code>IniDispatch::data</code>,
<code>IniDispatch::value</code> and <code>IniDispatch::append_to</code> and the fields
<code>IniDispatch::type</code>, <code>IniDispatch::d_len</code>, <code>IniDispatch::v_len</code> and
<code>IniDispatch::at_len</code>, are constantly reset, so feel free to use them as
custom placeholders if you like &ndash; but check their types:
<code>IniDispatch::type</code> has only eight bits available and
<code>IniDispatch::append_to</code> will always point to a <code>const</code> buffer.</li>
  <li>The numerical field <code>IniDispatch::dispatch_id</code> will be checked right before
the next dispatch, so you should not edit it. The reading happens only as
further diagnostics: if you constantly set this field to <code>0</code> the loop will
still end at the right moment (hopefully), but if you set it instead to a
value equal or higher than the <code>IniStatistics::members</code> previously received
the loop will immediately stop and a <code>CONFINI_EOOR</code> will be thrown (see
<code>enum</code> <code>ConfiniInterruptNo</code>). You can think of this as a dirty way of
writing <code>return !0</code> at the end of your listener. Unless you really know what
you are doing, do not edit <code>IniDispatch::dispatch_id</code>.</li>
</ol>

<p>Typical peaceful edits are the ones obtained by calling the functions
<code>ini_array_collapse()</code> and <code>ini_string_parse()</code> directly on the buffer
<code>IniDispatch::value</code>:</p>

<pre><code class="language-{.c}">/*  examples/topics/ini_string_parse.c  */

#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

static int ini_listener (
  IniDispatch * const dispatch,
  void * const v_null
) {

  if (
    dispatch-&gt;type == INI_KEY || dispatch-&gt;type == INI_DISABLED_KEY
  ) {

    ini_unquote(dispatch-&gt;data, dispatch-&gt;format);
    ini_string_parse(dispatch-&gt;value, dispatch-&gt;format);

  }

  printf(
    "DATA: %s\nVALUE: %s\nNODE TYPE: %u\n\n",
    dispatch-&gt;data,
    dispatch-&gt;value,
    dispatch-&gt;type
  );

  return 0;

}

int main () {

  if (
    load_ini_path(
      "../ini_files/self_explaining.conf",
      INI_DEFAULT_FORMAT,
      NULL,
      ini_listener,
      NULL
    )
  ) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  return 0;

}
</code></pre>

<p>If all these rules, although thoroughly exposed, sound still confusing to you,
use always <code>strndup()</code> on the strings dispatched and feel free to edit your own
buffers as you wish. Under <code>examples/utilities/clone_ini_dispatch.h</code> you can
find a function designed to make a hard copy of an entire <code>IniDispatch</code>,
including all the strings that this points to.</p>

<h3 id="FORMATTING-THE-VALUES">FORMATTING THE VALUES</h3>

<p>Once your listener starts to receive the parsed data you may want to format and
better parse the <code>value</code> part of key-value elements. The following functions
might be useful for this purpose:</p>

<ul>
  <li><code>ini_get_bool()</code></li>
  <li><code>ini_get_bool_i()</code></li>
  <li><code>ini_string_parse()</code></li>
  <li><code>ini_array_get_length()</code></li>
  <li><code>ini_array_foreach()</code></li>
  <li><code>ini_array_collapse()</code></li>
  <li><code>ini_array_break()</code></li>
  <li><code>ini_array_release()</code></li>
  <li><code>ini_array_shift()</code></li>
  <li><code>ini_array_split()</code></li>
</ul>

<p>Together with the functions listed above the following links are available, in
case you don't have <code>include &lt;stdlib.h&gt;</code> in your source:</p>

<ul>
  <li>
<code>ini_get_int()</code> = <a href="http://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html#index-atoi"><strong><code>atoi()</code></strong></a>
</li>
  <li>
<code>ini_get_lint()</code> = <a href="http://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html#index-atol"><strong><code>atol()</code></strong></a>
</li>
  <li>
<code>ini_get_llint()</code> = <a href="http://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html#index-atoll"><strong><code>atoll()</code></strong></a>
</li>
  <li>
<code>ini_get_double()</code> = <a href="http://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html#index-atof"><strong><code>atof()</code></strong></a>
</li>
</ul>

<p>Further useful resources include:</p>

<ul>
  <li><code>examples/utilities/clone_ini_dispatch.h</code></li>
  <li><code>examples/utilities/make_strarray.h</code></li>
</ul>

<h3 id="FORMATTING-THE-KEY-NAMES">FORMATTING THE KEY NAMES</h3>

<p>The function <code>ini_unquote()</code> can be useful for key names enclosed within
quotes. This function is very similar to <code>ini_string_parse()</code>, except that does
not bother collapsing the sequences of more than one space that might result
from removing empty quotes &ndash; this is never necessary, since empty quotes
surrounded by spaces in key and section names are always automatically
collapsed before being dispatched.</p>

<p>You could use <code>ini_string_parse()</code> as well to parse key and section names, but
you would obtain the same result with a slightly bigger effort from the CPU.</p>

<h3 id="FORMATTING-THE-SECTION-PATHS">FORMATTING THE SECTION PATHS</h3>

<p>In order to retrieve the parts of a section path, the functions
<code>ini_array_get_length()</code>, <code>ini_array_foreach()</code>, <code>ini_array_break()</code>,
<code>ini_array_release()</code>, <code>ini_array_shift()</code> and <code>ini_array_split()</code> can be used
with <code>'.'</code> or <code>INI_DOT</code> as delimiter (see <code>enum</code> <code>IniDelimiters</code>). Note that
section paths dispatched by <strong>libconfini</strong> are always collapsed arrays,
therefore calling the function <code>ini_array_collapse()</code> on them will have no
effects.</p>

<p>It might be required that the function <code>ini_unquote()</code> be applied to each part
of a section path, depending on the content and the format of the INI file.</p>

<h2 id="IMPLICIT-KEYS">IMPLICIT KEYS</h2>

<p>In order to set the value to assign to implicit keys (i.e. keys without a
delimiter and a value), please use the <code>ini_global_set_implicit_value()</code>
function. A <code>true</code> boolean is usually a good choice:</p>

<pre><code class="language-{.c}">ini_global_set_implicit_value("YES", 3);
</code></pre>

<p>Alternatively, instead of <code>ini_global_set_implicit_value()</code> you can manually
declare at the beginning of your code the two global variables
<code>INI_GLOBAL_IMPLICIT_VALUE</code> and <code>INI_GLOBAL_IMPLICIT_V_LEN</code>, which will be
retrieved by <strong>libconfini</strong>:</p>

<pre><code class="language-{.c}">#include &lt;confini.h&gt;

char * INI_GLOBAL_IMPLICIT_VALUE = "YES";
size_t INI_GLOBAL_IMPLICIT_V_LEN = 3;
</code></pre>

<p>Or you can assign a value to them at the beginning of the <code>main()</code> function of
your program:</p>

<pre><code class="language-{.c}">#include &lt;confini.h&gt;

int main () {

  INI_GLOBAL_IMPLICIT_VALUE = "YES";
  INI_GLOBAL_IMPLICIT_V_LEN = 3;

  /* ... */

}
</code></pre>

<p>If not defined elsewhere, these variables are initialized respectively to
<code>NULL</code> and <code>0</code> by default.</p>

<p>Although the two variables <code>INI_GLOBAL_IMPLICIT_VALUE</code> and
<code>INI_GLOBAL_IMPLICIT_V_LEN</code> are used only as placeholders for custom
information accessible solely by the user, starting from version 1.14.0 it is
safer to make <code>INI_GLOBAL_IMPLICIT_V_LEN</code> match <em>exactly</em> the real length of
<code>INI_GLOBAL_IMPLICIT_VALUE</code> (without counting the <code>NUL</code> terminator). By doing
so it is possible to make <strong>libconfini</strong> aware of a segment of memory that must
be protected from writing operations.</p>

<p>After having set the value to be assigned to implicit key elements, and having
enabled <code>IniFormat::implicit_is_not_empty</code> in the format, it is possible to
test whether a dispatched key is implicit or not by comparing the address of
its <code>value</code> property with the global variable <code>INI_GLOBAL_IMPLICIT_VALUE</code>:</p>

<pre><code class="language-{.c}">/*  examples/topics/ini_global_set_implicit_value.c  */

#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

static int ini_listener (
  IniDispatch * const dispatch,
  void * const v_null
) {

  if (dispatch-&gt;value == INI_GLOBAL_IMPLICIT_VALUE) {

    printf(
      "\nDATA: %s\nVALUE: %s\nNODE TYPE: %u\n"
      "(This is an implicit key element)\n",

      dispatch-&gt;data,
      dispatch-&gt;value,
      dispatch-&gt;type
    );

  } else {

    printf(
      "\nDATA: %s\nVALUE: %s\nNODE TYPE: %u\n",

      dispatch-&gt;data,
      dispatch-&gt;value,
      dispatch-&gt;type
    );

  }

  return 0;

}

int main () {

  IniFormat my_format = INI_UNIXLIKE_FORMAT;

  ini_global_set_implicit_value("[implicit default value]", 24);

  /*  Without this implicit keys will be considered empty  */
  my_format.implicit_is_not_empty = true;
  my_format.disabled_can_be_implicit = true;

  if (
    load_ini_path(
      "../ini_files/unix-like.conf",
      my_format,
      NULL,
      ini_listener,
      NULL
    )
  ) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

}
</code></pre>

<p>Implicit keys can be parsed as booleans also without setting
<code>IniFormat::implicit_is_not_empty</code> to <code>true</code>. By doing so there will be no
distinction between empty and implicit keys, and there are situations where
this can be a wanted behavior. The following example will parse both <code>my_key</code>
and <code>my_key =</code> in the INI file as <code>true</code>:</p>

<pre><code class="language-{.c}">/*  `dsp-&gt;format.implicit_is_not_empty` is `false` here!  */
bool my_boolean;
if (ini_string_match_si("my_key", dsp-&gt;data, dsp-&gt;format)) {
  my_boolean = (bool) ini_get_bool_i(dsp-&gt;value, 1, dsp-&gt;format);
}
</code></pre>

<h2 id="CODE-CONSIDERATIONS">CODE CONSIDERATIONS</h2>

<h3 id="RETURN-VALUES">RETURN VALUES</h3>

<p>The functions <code>load_ini_file()</code>, <code>load_ini_path()</code>, <code>strip_ini_cache()</code>,
<code>ini_array_foreach()</code> and <code>ini_array_split()</code> require some listeners defined by
the user. Such listeners must return an <code>int</code> value. When this is non-zero the
caller function is interrupted, its loop stopped, and a non-zero value is
returned by the caller as well.</p>

<p>The functions <code>load_ini_file()</code>, <code>load_ini_path()</code> and <code>strip_ini_cache()</code>
return a non-zero value also if the INI file, for any reason, has not been
completely parsed (see <code>enum</code> <code>ConfiniInterruptNo</code>). Therefore, in order to be
able to distinguish between internal errors and user-generated interruptions
the mask <code>CONFINI_ERROR</code> can be used.</p>

<p>For instance, in the following example the <code>f_foreach()</code> listener returns a
non-zero value if a key named <code>password</code> with a value that equals <code>Hello world</code>
is found. Hence, by using the mask <code>CONFINI_ERROR</code>, the code below
distinguishes a non-zero value generated by the listener from a non-zero value
due to a parsing error.</p>

<pre><code class="language-{.c}">/*  examples/topics/ini_string_match_si.c  */

#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

static int passfinder (
  IniDispatch * const disp,
  void * const v_membid
) {

  /*  Search for `password = "hello world"` in the INI file  */
  if (
    ini_string_match_si("password", disp-&gt;data, disp-&gt;format) &amp;&amp;
    ini_string_match_si("hello world", disp-&gt;value, disp-&gt;format)
  ) {

    *((size_t *) v_membid) = disp-&gt;dispatch_id;
    return 1;

  }

  return 0;

}

int main () {

  size_t membid;

  /*  Load INI file  */
  int retval = load_ini_path(
    "../ini_files/self_explaining.conf",
    INI_DEFAULT_FORMAT,
    NULL,
    passfinder,
    &amp;membid
  );

  /*  Check for errors  */
  if (retval &amp; CONFINI_ERROR) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  /*  Check if parsing has been interrupted by `passfinder()`  */
  retval  ==  CONFINI_FEINTR ?
                printf(
                  "We found it! It's the INI node number %zu!\n",
                  membid
                )
              :
                printf("We didn't find it :-(\n");

  return 0;

}
</code></pre>

<h3 id="THE-FORMATTING-FUNCTIONS">THE FORMATTING FUNCTIONS</h3>

<p>The functions <code>ini_unquote()</code>, <code>ini_string_parse()</code>, <code>ini_array_collapse()</code>,
<code>ini_array_break()</code>, <code>ini_array_release()</code> and <code>ini_array_split()</code> change the
content of the given strings. It is important to point out that the edit is
always performed within the lengths of the strings given.</p>

<p>The behavior of these functions depends on the format used. In particular,
using <code>ini_string_parse()</code> as a model one obtains the following scheme:</p>

<ol>
  <li>Condition: <code>!format.no_single_quotes &amp;&amp; !format.no_double_quotes &amp;&amp;
format.multiline_nodes != INI_NO_MULTILINE</code><br>
&rArr; Escape sequences: <code>\\</code>, <code>\"</code>, <code>\'</code><br>
&rArr; Behavior of <code>ini_string_parse()</code>: <code>\\</code>, <code>\'</code> and <code>\"</code> will be unescaped,
all unescaped single and double quotes will be removed, then the new length
of the string will be returned.</li>
  <li>Condition: <code>!format.no_single_quotes &amp;&amp; format.no_double_quotes &amp;&amp;
format.multiline_nodes != INI_NO_MULTILINE</code><br>
&rArr; Escape sequences: <code>\\</code>, <code>\'</code><br>
&rArr; Behavior of <code>ini_string_parse()</code>: <code>\\</code> and <code>\'</code> will be unescaped, all
unescaped single quotes will be removed, then the new length of the string
will be returned.</li>
  <li>Condition: <code>format.no_single_quotes &amp;&amp; !format.no_double_quotes &amp;&amp;
format.multiline_nodes != INI_NO_MULTILINE</code><br>
&rArr; Escape sequences: <code>\\</code>, <code>\"</code><br>
&rArr; Behavior of <code>ini_string_parse()</code>: <code>\\</code> and <code>\"</code> will be unescaped, all
unescaped double quotes will be removed, then the new length of the string
will be returned.</li>
  <li>Condition: <code>format.no_single_quotes &amp;&amp; format.no_double_quotes &amp;&amp;
format.multiline_nodes != INI_NO_MULTILINE</code><br>
&rArr; Escape sequences: <code>\\</code><br>
&rArr; Behavior of <code>ini_string_parse()</code>: only <code>\\</code> will be unescaped, spaces at
the beginning and at the end of the string will be removed, then the new
length of the string will be returned.</li>
  <li>Condition: <code>format.no_single_quotes &amp;&amp; format.no_double_quotes &amp;&amp;
format.multiline_nodes == INI_NO_MULTILINE</code><br>
&rArr; Escape sequences: No escape sequences<br>
&rArr; Behavior of <code>ini_string_parse()</code>: Spaces at the beginning and at the end
of the string will be removed, then the new length of the string will be
returned.</li>
</ol>

<p>A function-like macro named <code>INIFORMAT_HAS_NO_ESC()</code> is available in order to
check whether a format supports escape sequences or not.</p>

<p>It is possible to extend the list of supported escape sequences by parsing
additional ones before invoking <code>ini_string_parse()</code>. Under
<code>examples/utilities/ini_string_preparse.h</code> there is a little helper function
that adds support to the following sequences: <code>"\a"</code>, <code>"\b"</code>, <code>"\f"</code>, <code>"\n"</code>,
<code>"\r"</code>, <code>"\t"</code>, <code>"\v"</code> and <code>"\e"</code>. It must be used right before <code>ini_unquote()</code>
or <code>ini_string_parse()</code>, since it relies on the latter for unescaping double
backslashes:</p>

<pre><code class="language-{.c}">#include &lt;confini.h&gt;
#include "examples/utilities/ini_string_preparse.h"

static int my_callback (IniDispatch * disp, void * user_data) {

  if (disp-&gt;type == INI_KEY) {

    /*  Add support for \a, \b, \f, \n, \r, \t, \v and \e  */
    ini_string_preparse(disp-&gt;value);
    ini_string_parse(disp-&gt;value, disp-&gt;format);

    /*  DO SOMETHING  */

  }

  return 0;

}
</code></pre>

<h3 id="COMMON-MISTAKES">COMMON MISTAKES</h3>

<p>The native formatting functions <code>ini_array_break()</code>, <code>ini_array_collapse()</code>,
<code>ini_array_release()</code>, <code>ini_array_split()</code>, <code>ini_string_parse()</code> and
<code>ini_unquote()</code> have a special safeguard against attempting to edit the global
variable <code>INI_GLOBAL_IMPLICIT_VALUE</code>. But if you use your own functions for
editing the dispatches received, you must always make sure that
<code>dispatch-&gt;value != INI_GLOBAL_IMPLICIT_VALUE</code> in formats where
<code>IniFormat::implicit_is_not_empty</code> is set to <code>true</code> &ndash; otherwise a
&ldquo;Segmentation fault (core dumped)&rdquo; error can be generated.</p>

<pre><code class="language-{.c}">#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

static void my_editing_function (char * const my_string) {

  if (!my_string) {

    return;

  }

  /*  Only a random edit...  */
  my_string[0] = '\0';

}

static int my_callback (IniDispatch * dispatch, void * v_null) {

  /*
    This will always work: `libconfini` formatting function have a
    safeguard against attempting to edit the global variable
    `INI_GLOBAL_IMPLICIT_VALUE`...
  */
  ini_string_parse(dispatch-&gt;value, dispatch-&gt;format);

  /*
    This can cause a `Segmentation fault (core dumped)` error when
    `dispatch-&gt;format.implicit_is_not_empty` is set to `true` and
    `dispatch-&gt;value` is an implicit boolean. In cases like this, if
    you don't want to `strndup(dispatch-&gt;value, dispatch-&gt;v_len)`,
    you must always check that
   `dispatch-&gt;value != INI_GLOBAL_IMPLICIT_VALUE`!
  */
  my_editing_function(dispatch-&gt;value);

  printf(
    "DATA: %s\nVALUE: %s\nNODE TYPE: %u\n\n",
    dispatch-&gt;data, dispatch-&gt;value, dispatch-&gt;type
  );

  return 0;

}

int main () {

  ini_global_set_implicit_value("YES", 3);
  IniFormat myformat = INI_DEFAULT_FORMAT;
  myformat.implicit_is_not_empty = true;
  myformat.disabled_can_be_implicit = true;

  if (load_ini_path(
    "examples/ini_files/typed_ini.conf",
    myformat,
    NULL,
    my_callback,
    NULL
  )) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  return 0;

}
</code></pre>

<p>To check whether a particular substring belongs to
<code>INI_GLOBAL_IMPLICIT_VALUE</code>, the <code>INI_IS_IMPLICIT_SUBSTR()</code> macro can be used:</p>

<pre><code class="language-{.c}">if (dispatch-&gt;v_len &gt; 0) {

  /*  Let us create a substring of `dispatch-&gt;value`...  */
  char * my_substring = dispatch-&gt;value + 1;

  printf("%s\n", my_substring);

  if (INI_IS_IMPLICIT_SUBSTR(my_substring)) {

    printf("\n\tYou tricky one! This was an implicit value too!\n");

  }

return 0;
</code></pre>

<h3 id="STORING-THE-DISPATCHED-DATA">STORING THE DISPATCHED DATA</h3>

<p>In order to be as flexible as possible, <strong>libconfini</strong> does not store the
dispatched data, nor indicizes them. This gives developers the power to deal
with them in many different ways.</p>

<p>For small INI files a normal if/else chain, using <code>ini_array_match()</code> for
comparing section paths and <code>ini_string_match_si()</code>/<code>ini_string_match_ii()</code> for
comparing key names, usually represents the most practical way to obtain the
information required from an INI file. Sometimes however, especially in case of
sizeable INI files, the most efficient solution would be to store the parsed
data in a hash table before trying to access it.</p>

<p>Some INI parsers are released with a hash table API included by default. This
is often an unpractical solution, since fantastic free software libraries that
focus solely on hash tables already exist, and providing a further API for
managing a hash function together with an INI parser only complicates the code,
makes it harder to maintain, and does not give the user the real freedom to
choose what suits best to each single case. Some programming languages have
even hash tables in their standard libraries (see <code>std::map</code> in C++ for
example).</p>

<p>When needed, the data parsed by <strong>libconfini</strong> can still be stored in a hash
table while it is being dispatched. If you are interested in combining
<strong>libconfini</strong> with a hash table, I have left a general example of how to use
<strong>GLib</strong>'s <code>GHashTable</code> together with <strong>libconfini</strong> under
<code>examples/miscellanea/glib_hash_table.c</code>. If you are using C++, you can find an
example of how to construct a C++ class that relies on a <code>std::unordered_map</code>
object under <code>examples/cplusplus/map.cpp</code>. By keeping these examples as models
other solutions can be easily explored as well.</p>

<h3 id="SIZE-OF-THE-DISPATCHED-DATA">SIZE OF THE DISPATCHED DATA</h3>

<p>Writing</p>

<pre><code class="language-{.c}">char * buf  =   malloc(stats-&gt;bytes + stats-&gt;members + (
                  stats-&gt;format.implicit_is_not_empty ?
                    INI_GLOBAL_IMPLICIT_V_LEN * stats-&gt;members
                  :
                    0
                ) + 1);
</code></pre>

<p>will always allocate the smallest buffer large enough to store all the
<code>IniDispatch::data</code> and <code>IniDispatch::value</code> received, including their <code>NUL</code>
terminators and any possible implicit value.</p>

<p>This buffer will not be capable enough to store also the
<code>IniDispatch::append_to</code> strings received (about which no information is
available at early stages). However, thanks to the syntax of INI files, where a
key is always appended to the section previously dispatched, it will be always
possible to store the information about the structure of the tree by using
numbers as references to the parents instead of copying verbatim the
<code>IniDispatch::append_to</code> strings. This will also result in a more efficient
code.</p>

<pre><code class="language-{.c}">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;confini.h&gt;

static int my_stats_listener (
  IniStatistics * stats,
  void * v_destptr
) {

  #define destptr ((char **) v_destptr)

  *destptr  =   malloc(stats-&gt;bytes + stats-&gt;members + (
                  stats-&gt;format.implicit_is_not_empty ?
                    INI_GLOBAL_IMPLICIT_V_LEN * stats-&gt;members
                  :
                    0
                ) + 1);

  return 0;

  #undef destptr

}


static int my_ini_listener (
  IniDispatch * this,
  void * v_my_capable_buffer
) {

  /*  Store the dispatched data in `my_capable_buffer`  */
  char ** my_capable_buffer = (char **) v_my_capable_buffer;
  /*  ...  */

  return 0;

}

int main () {

  /*  In real life we would need a more complex `struct` here...  */
  char * my_copied_data;

  /*  Load the INI file  */
  if (load_ini_path(
    "test.conf",
    INI_DEFAULT_FORMAT,
    my_stats_listener,
    my_ini_listener,
    &amp;my_copied_data
  )) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  return 0;

}
</code></pre>

<h3 id="OTHER-GLOBAL-SETTINGS">OTHER GLOBAL SETTINGS</h3>

<p>In the past, besides the two global variables <code>INI_GLOBAL_IMPLICIT_VALUE</code> and
<code>INI_GLOBAL_IMPLICIT_V_LEN</code>, a third variable named
<code>INI_GLOBAL_LOWERCASE_MODE</code> would tell <strong>libconfini</strong> whether to dispatch in
lower case all key names and section paths of case-insensitive INI files.
This variable rarely needed to be set to <code>true</code>, since string comparisons made
by libconfini are always either case-sensitive or case-insensitive depending on
the format given.</p>

<p>This &ldquo;dispatch in lowercase&rdquo; functionality itself was a relic from a time when
<strong>libconfini</strong> did not yet possess any string comparison functions. This is no
longer the case and there are now four functions for that, therefore starting
from version 1.15.0 both the <code>INI_GLOBAL_IMPLICIT_VALUE</code> variable and the
<code>ini_global_set_lowercase_mode()</code> function have been marked as deprecated (see
the <strong>list of deprecated functions and variables</strong>). If needed, to convert to
lowercase key names and section paths in case-insensitive INI files it is
possible to use the following simple snippet, which maps exactly what
<strong>libconfini</strong> would do:</p>

<pre><code class="language-{.c}">static inline void string_tolower (char * const str) {
  for (register char * ptr = str; *ptr; ptr++) {
    *ptr = *ptr &gt; 0x40 &amp;&amp; *ptr &lt; 0x5b ? *ptr | 0x60 : *ptr;
  }
}

static int my_callback (IniDispatch * dispatch, void * v_null) {

  if (!dispatch-&gt;format.case_sensitive) {
    switch (dispatch-&gt;type) {
      case INI_KEY:
      case INI_DISABLED_KEY:
      case INI_SECTION:
      case INI_DISABLED_SECTION:
        string_tolower(dispatch-&gt;data);
    }

  }

  /*  DO SOMETHING...  */

 return 0;

}
</code></pre>

<h3 id="THE-UNICODE-PROBLEM">THE UNICODE PROBLEM</h3>

<p>Comparing an ASCII upper case letter to an ASCII lower case letter is an
invariant process. But comparing two Unicode letter cases is a process that
depends on the locale of the machine. Consider for example the lower case
letter <code>i</code>: in most European languages its upper case is <code>I</code>, while this is not
the case in Turkish, where the upper case of <code>i</code> is <code>&#304;</code> (and the lower case of
<code>I</code> is <code>&#305;</code>). Therefore for a person living in Italy or France, <code>i</code> and <code>I</code> will
represent the same letter, while for a person living in Turkey they will not.</p>

<p>Key and section names of an INI file however cannot depend on the locale of the
machine, since they must be reliably searched for independently of where a
machine is located. Imagine for example a key named &ldquo;INI&rdquo; and imagine that
Unicode case folding were performed on key names during string comparisons. If
you lived in Europe you could look up for such key using its lower case &ldquo;ini&rdquo;,
while if you lived in Turkey you would have to use the lower case &ldquo;&#305;n&#305;&rdquo; to find
it. So the only solution in this context is to consider Unicode characters out
of the ASCII range always as case-sensitive. For this reason, <strong>libconfini</strong>
(and probably any senseful INI parser) will never perform case folding of
Unicode characters out of the ASCII range within key and section names.</p>

<p>It must be said that most Unicode characters do not possess a lower and upper
case, and most characters outside of the ASCII range could theoretically appear
without problems in key and section names also in case-insensitive INI files
(think of the character <code>&sect;</code> for example). And, as for case-sensitive INI files,
no Unicode character would ever represent a problem. Nonetheless, it is
generally more acceptable to use ASCII only within key and section names &ndash; and
possibly, if needed, non-ASCII Unicode characters within values and comments.</p>

<p>That said, <strong>libconfini</strong> deals perfectly fine with UTF-8 (but is always
case-sensitive outside of the ASCII range), so use the latter as you feel
appropriate.</p>

<h3 id="THREAD-SAFETY">THREAD SAFETY</h3>

<p>Depending on the format of the INI file, <strong>libconfini</strong> may use up to three
global variables (<code>INI_GLOBAL_IMPLICIT_VALUE</code>, <code>INI_GLOBAL_IMPLICIT_V_LEN</code>
and <code>INI_GLOBAL_LOWERCASE_MODE</code>). In order to be thread-safe these three
variables (if needed) must be defined only once (either directly, or by using
their setter functions <code>ini_global_set_implicit_value()</code> and
<code>ini_global_set_lowercase_mode()</code>), or otherwise a mutex logic must be
introduced.</p>

<p>Apart from the three variables above, each parsing allocates and frees its own
memory and every function is fully reentrant, therefore the library can be
considered thread-safe.</p>

<h3 id="ERROR-EXCEPTIONS">ERROR EXCEPTIONS</h3>

<p>The philosophy of <strong>libconfini</strong> is to parse as much as possible without
generating error exceptions. No parsing errors are returned once an INI file
has been correctly allocated into the heap, with the exception of the
<em>out-of-range</em> error <code>CONFINI_EOOR</code> (see <code>enum</code> <code>ConfiniInterruptNo</code>), whose
meaning is that the dispatches are for unknown reasons more than expected &ndash; 
this error is possibly generated by the presence of bugs in the library's code
and should <strong>never</strong> be returned (please <a href="https://github.com/madmurphy/libconfini/issues">contact me</a> if this happens).</p>

<p>When an INI node is wrongly written in respect to the format given, it is
dispatched verbatim as an <code>INI_UNKNOWN</code> node &ndash; see <code>enum</code> <code>IniNodeType</code>.
Empty lines, or lines containing only spaces and empty quotes (if the latter
are supported) will be skipped.</p>

<p>In order to avoid error exceptions, strings containing an unterminated quote
will be always treated as if they had a virtual quote as their last + 1
character. For example,</p>

<pre><code class="language-{.ini}">foo = "bar
</code></pre>

<p>will always determine the same behavior as if it had been</p>

<pre><code class="language-{.ini}">foo = "bar"
</code></pre>

<p>Any format containing the following three settings will never produce
<code>INI_UNKNOWN</code> nodes, even if instead of an INI file we tried to parse a .jpeg
image (or anything else):</p>

<pre><code class="language-{.c}">IniFormat my_format = {
  .delimiter_symbol = INI_ANY_SPACE,
  .section_paths = INI_NO_SECTIONS,
  .no_spaces_in_names = false,
  ...
};
</code></pre>

<h3 id="PERFORMANCE">PERFORMANCE</h3>

<p>The algorithms used by <strong>libconfini</strong> stand in a delicate equilibrium between
flexibility, speed and code readability, with flexibility as primary target.
Performance can vary with the format used to parse an INI file, but in most
cases is not a concern.</p>

<p>One can measure the performance of the library by doing something like:</p>

<pre><code class="language-{.c}">/*  dev/tests/performance/performance.c  */

#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;
#include &lt;time.h&gt;

static int get_ini_size (IniStatistics * stats, void * v_bytes) {

  *((size_t *) v_bytes) = stats-&gt;bytes;
  return 0;

}

static int empty_listener (IniDispatch * dispatch, void * v_bytes) {

  return 0;

}

int main () {

  size_t bytes;
  double seconds;

  clock_t start, end;
  start = clock();

  /*  Please create an INI file large enough  */
  if (load_ini_path(
    "big_file.ini",
    INI_DEFAULT_FORMAT,
    get_ini_size,
    empty_listener,
    &amp;bytes
  )) {

    return 1;

  }

  end = clock();
  seconds = (double) (end - start) / CLOCKS_PER_SEC;

  printf(
    "%zu bytes parsed in %f seconds.\n"
    "Number of bytes parsed per second: %f\n",
    bytes, seconds, (double) bytes / seconds
  );

  return 0;

}
</code></pre>

<p>By changing the format of the INI file on the code above one might obtain
different results. In particular, switching disabled entry recognition off &ndash; 
by setting <code>IniFormat::semicolon_marker</code> and <code>IniFormat::hash_marker</code> to
<code>INI_ONLY_COMMENT</code> or <code>INI_IGNORE</code> &ndash; and making the format non-multi-line &ndash; 
by setting <code>IniFormat::multiline_nodes</code> to <code>INI_NO_MULTILINE</code> &ndash; will have a
positive impact on the performance.</p>

<p>On my laptop <strong>libconfini</strong> seems to parse around 95 MiB per second using the
model format <code>INI_DEFAULT_FORMAT</code>. Whether this is enough for you or not, that
depends on your needs.</p>

<pre><code>53411840 bytes (1146880 nodes) parsed in 0.533315 seconds.
Number of bytes parsed per second: 100150642.678342
</code></pre>

<p>If you are interested in testing yourself the library's performance on a
particular hardware you can find a performance test under
<code>dev/tests/performance</code>.</p>

<h2 id="INI-SYNTAX-CONSIDERATIONS">INI SYNTAX CONSIDERATIONS</h2>

<h3 id="COMMENT-OR-DISABLED-ENTRY-">COMMENT OR DISABLED ENTRY?</h3>

<p>It is hard to imagine a reason to be interested in disabled entries if not for
writing a GUI editor for INI files. If this is the case and you are not using
<strong>libconfini</strong> like normal people do, you might wonder how to ensure that
disabled entries and comments be always parsed without ambiguity.</p>

<p>In most of the cases <strong>libconfini</strong> is smart enough to distinguish a disabled
entry from a comment. However some INI files can be tricky and might require
some workarounds. For instance, imagine the following INI file:</p>

<pre><code class="language-{.ini}"># INI KEY/VALUE DELIMITER: `=`

[some_section]

hello = world

;foo = bar

##now=Sunday April 3rd, 2016
</code></pre>

<p>And imagine that for unknown reasons the author of the INI file wanted only
<code>;foo = bar</code> to be considered as a disabled entry, and the first and last line
as normal comments.</p>

<p>If we tried to parse it according to the format used below</p>

<pre><code class="language-{.c}">#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

static int ini_listener (IniDispatch * dispatch, void * v_null) {

  printf(
    "Node #%zu - Type: %u; Data: \"%s\"; Value: \"%s\"\n",
    dispatch-&gt;dispatch_id,
    dispatch-&gt;type,
    dispatch-&gt;data,
    dispatch-&gt;value
  );

  return 0;

}

int main () {

  #define MY_FORMAT \
    ((IniFormat) { \
      .delimiter_symbol = INI_EQUALS, \
      .case_sensitive = false, \
      .semicolon_marker = INI_DISABLED_OR_COMMENT, \
      .hash_marker = INI_DISABLED_OR_COMMENT, \
      .multiline_nodes = INI_NO_MULTILINE, \
      .section_paths = INI_ABSOLUTE_ONLY, \
      .no_single_quotes = false, \
      .no_double_quotes = false, \
      .no_spaces_in_names = false, \
      .implicit_is_not_empty = true, \
      .do_not_collapse_values = false, \
      .preserve_empty_quotes = false, \
      .disabled_after_space = true, \
      .disabled_can_be_implicit = true \
    })

  printf(":: Content of \"ambiguous.conf\" ::\n\n");

  if (load_ini_path(
    "../ini_files/ambiguous.conf",
    MY_FORMAT,
    NULL,
    ini_listener,
    NULL
  )) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  return 0;

}
</code></pre>

<p>we would obtain the following result:</p>

<pre><code>:: Content of "ambiguous.conf" ::

Node #0 - Type: 6; Data: "INI KEY/VALUE DELIMITER: `"; Value: "`"
Node #1 - Type: 3; Data: "some_section"; Value: ""
Node #2 - Type: 2; Data: "hello"; Value: "world"
Node #3 - Type: 6; Data: "foo"; Value: "bar"
Node #4 - Type: 4; Data: "now=Sunday April 3rd, 2016"; Value: ""
</code></pre>

<p>As you can see, all comments but <code>now=Sunday April 3rd, 2016</code> would be parsed
as disabled entries &ndash; which is not what the author intended. Therefore, to
ensure that such INI file be parsed properly, you can follow two possible
approaches.</p>

<p><strong>1. Intervene on the INI file.</strong> The reason why <code>now=Sunday April 3rd, 2016</code>
has been properly parsed as a comment &ndash; despite it really looks like a
disabled entry &ndash; is because it has been nested within a comment block opened
by more than one leading marker (in this case the two <code>#</code>). As a general rule,
<em><strong>libconfini</strong> never parses a comment beginning with more than one leading
marker as a disabled entry</em>, therefore this is the surest way to ensure that
proper comments are always considered as such.</p>

<p>Hence, by adding one more number sign to the first comment</p>

<pre><code class="language-{.ini}">## INI KEY/VALUE DELIMITER: `=`

[some_section]

hello = world

;foo = bar

##now=Sunday April 3rd, 2016
</code></pre>

<p>we obtain the wanted result:</p>

<pre><code>:: Content of "ambiguous.conf" ::

Node #0 - Type: 4; Data: " INI KEY/VALUE DELIMITER: `=`"; Value: ""
Node #1 - Type: 3; Data: "some_section"; Value: ""
Node #2 - Type: 2; Data: "hello"; Value: "world"
Node #3 - Type: 6; Data: "foo"; Value: "bar"
Node #4 - Type: 4; Data: "now=Sunday April 3rd, 2016"; Value: ""
</code></pre>

<p><strong>2. Intervene on the format.</strong> There are cases where the INI file is
automatically generated by machines (comments included), or distributed as
such, and human intervention would be required on each machine-generated
release of the INI file. In these cases &ndash; and if we are sure about the
expected content of the INI file &ndash; we can restrict the format chosen in order
to parse comments and disabled entries properly. In particular, the following
fields of the <code>IniFormat</code> bitfield can have an impact on the disambiguation
between comments and disabled entries.</p>

<p>Reliable general patterns:</p>

<ul>
  <li>
<code>IniFormat::semicolon_marker</code> and <code>IniFormat::hash_marker</code> &ndash; The imaginary
author of our INI file, if we observe the latter closer, chose the semicolon
symbol as the marker of disabled entries and the hash symbol as the marker of
comments. We may exploit this difference and set our
<code>my_format.semicolon_marker</code> to <code>INI_DISABLED_OR_COMMENT</code> and our
<code>my_format.hash_marker</code> to <code>INI_ONLY_COMMENT</code> to obtain the correct
disambiguation. If you believe that this solution is too artificial, think
that <code>/etc/samba/smb.conf</code> and <code>/etc/pulse/daemon.conf</code> are systematically
distributed using this pattern.</li>
  <li>
<code>IniFormat::disabled_after_space</code> &ndash; Setting this property to <code>false</code>, due to
the initial space that follows the comment marker (<code># INI...</code>), forces the
entire line to be considered as a comment. Some authors use this syntax to
distinguish between comments and disabled entries (examples are
<code>/etc/pacman.conf</code> and <code>/etc/bluetooth/main.conf</code>)</li>
</ul>

<p>Temporary workarounds:</p>

<ul>
  <li>
<code>IniFormat::no_spaces_in_names</code> &ndash; If our INI file has only comments
containing more than one word and we are sure that key and section names
cannot contain internal white spaces, we can set this property to <code>true</code> to
enhance disambiguation.</li>
  <li>
<code>IniFormat::disabled_can_be_implicit</code> &ndash; This property, if set to <code>false</code>,
forces all comments that do not contain a key-value delimiter never to be
considered as disabled entries. Despite not having an impact on our example,
it has an impact on the disambiguation algorithms used by <strong>libconfini</strong>. Its
value in <code>INI_DEFAULT_FORMAT</code> is set to <code>false</code>.</li>
</ul>

<p>As a general rule, <strong>libconfini</strong> will always try to parse as a disabled entry
whatever comment is allowed (by the format) to contain one. Only if this
attempt fails, the block will be dispatched as a normal comment.</p>

  <ol class='man-decor man-foot man foot'>
    <li class='tl'>Stefano Gioffr&eacute;</li>
    <li class='tc'>September 2021</li>
    <li class='tr'>libconfini(3)</li>
  </ol>

  </div>
</body>
</html>
